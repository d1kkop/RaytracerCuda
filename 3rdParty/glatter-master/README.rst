Glatter
=======

Overview
--------

Glatter is an OpenGL loading library, with support for GL, GLES, EGL, GLX, WGL.
In addition to extension loading, it facilitates logging and error checking.


Building
--------

The library can be built in one of two ways:

1. by compiling src/glatter.c into your project, or
2. if used in c++ code, as a header-only library, by specifying ``GLATTER_HEADER_ONLY`` in ``glatter_config.h``, and then including ``glatter.h`` where necessary.

The latter will affect compilation time.

There are two Glatter headers that might need to be configured/modified, according to the needs of the user:

- ``glatter_system_headers.h``: 
  This is where the set of OpenGL headers is being included. 
- ``glatter_config.h``:
  It contains a set of macro declarations, that mostly enable or disable parts of the library or functionality.

A standard set of headers is supplied, which can be used in a fairly broad set of systems.
If needed, new custom headers can be generated by the python script (``tools/glatter.py``), which should parse directly the set of OpenGL headers that your application is built with.
Just place your headers under ``tools/input/headers`` and run the script.

Usage
-----

Glatter does not require initialization.
It only requires that the header is included, wherever its functionality is meant to be used.


Tracing calls, checking errors
------------------------------

Although there are the extensions ``ARB_debug_output`` and ``KHR_debug``, which serve a similar purpose, at least with regards to error checking, the asynchronous nature of OpenGL, makes their usage less convenient. The main issue with these extensions is that, depending on the implementation, the errors may only show when the OpenGL server reaches the erroneous calls in the command buffer, without providing a clear indication of where the problem in the source code really is.

Glatter performs this task by wrapping all library calls inside debug versions of each call.
There are two modes of debug operation, which can be switched on and off independently:

1. Logging (tracing) every OpenGL call, which can be enabled by defining ``GLATTER_LOG_CALLS`` in the configuration header
2. Logging only the errors produced by API calls, which may be enabled by defining ``GLATTER_LOG_ERRORS``. This is enabled by default, when ``NDEBUG`` is not defined.

Traces of calls with GLenum arguments, are shown with their arguments converted to readable strings.

Here is a pseudo-example, of legacy OpenGL code drawing something, traced with ``GLATTER_LOG_CALLS``:

  .. code-block:: c

	GLboolean r = glIsEnabled(GL_COLOR_MATERIAL);
	glBegin(GL_QUAD_STRIP);
	// ...
	glEnd();

For the above, Glatter could produce:

  .. code::

	GLATTER: in 'c:\repositories\glatter\example\glatter\wglgears.cpp'(133):
	GLATTER: glIsEnabled(GL_COLOR_MATERIAL)
	GLATTER: returned 0
	GLATTER: in 'c:\repositories\glatter\example\glatter\wglgears.cpp'(134):
	GLATTER: glBegin(GL_QUAD_STRIP)
	GLATTER: in 'c:\repositories\glatter\example\glatter\wglgears.cpp'(145):
	GLATTER: glEnd()

Let's now introduce an error, by passing an invalid enumerator in the glIsEnabled call:

  .. code-block:: c

	GLboolean r = glIsEnabled(GL_FRAMEBUFFER_RENDERABLE);


In this case, Glatter could produce:

  .. code::

	GLATTER: in 'c:\repositories\glatter\example\glatter\wglgears.cpp'(133):
	GLATTER: glIsEnabled(GL_FRAMEBUFFER_RENDERABLE)
	GLATTER: returned 0
	GLATTER: in 'c:\repositories\glatter\example\glatter\wglgears.cpp'(133):
	GLATTER: OpenGL call produced GL_INVALID_ENUM error.


License
-------
The source code of the library is licensed under the Simplified BSD License.
